# ESCT: Part 5 - Elixir Security

```elixir
Mix.install([:benchwarmer, :kino, :plug])
```

## Introduction

asdf

## Table of Contents

* [Atom Exhaustion](#atom-exhaustion)
* [Protecting Sensitive Data](#protecting-sensitive-data)
* [Untrusted Code](#untrusted-code)
* [Timing Attacks](#timing-attacks)
* [Boolean Coercion](#boolean-coercion)

## Atom Exhaustion

### Description

TODO: Describe

### Prevention

TODO: Prevent

### <span style="color:red;">Quiz</span>

**Fix the vulnerable function below by changing the String function used on line 7.**

*You should get a `true` result when you successfully fix the function.*

```elixir
random_number = :rand.uniform(10000)
malicious_user_input = Integer.to_string(random_number)
prev_count = :erlang.system_info(:atom_count)

try do
  malicious_user_input
  # ONLY CHANGE THIS LINE
  |> String.to_atom()
rescue
  e -> {ArgumentError, e}
end

IO.puts("Are you protected against Atom Exhaustion?")
IO.puts(:erlang.system_info(:atom_count) == prev_count)
```

## Protecting Sensitive Data

### Description

TODO: Describe

### Prevention

TODO: Prevent

```elixir

```

## Untrusted Code

### Description

TODO: Describe

### Prevention

TODO: Prevent

### <span style="color:blue;">Example</span>

TODO: Explain

```elixir
name = Kino.Input.text("What's your name?")
```

```elixir
textfield_value = Kino.Input.read(name)
{result, binding} = Code.eval_string("a", a: textfield_value)
"Hello, " <> result
```

**BONUS QUESTION**: How would you go about securing the code above?

Hint: Deleting it *entirely* is a fair approach ðŸ˜‰

## Timing Attacks

### Description

TODO: Describe

### Prevention

TODO: Prevent

### <span style="color:red;">Quiz</span>

TODO: Explain

```elixir
defmodule Susceptible do
  def compare(input, value) do
    case input do
      ^value -> :ok
      _ -> :access_denied
    end
  end
end

defmodule Constant do
  def compare(input, value) do
    case Plug.Crypto.secure_compare(input, value) do
      true -> :ok
      false -> :access_denied
    end
  end
end

password = "HASH_OF_THE_USERS_ACTUAL_PASSWORD"
# DO NOT EDIT ANY CODE ABOVE THIS LINE =====================

user_input = "HASH_OF_asdfasdf"

# DO NOT EDIT ANY CODE BELOW THIS LINE (you may uncomment IO.puts) =============
Benchwarmer.benchmark(fn -> Susceptible.compare(user_input, password) end)
Benchwarmer.benchmark(fn -> Constant.compare(user_input, password) end)

# IO.puts(:comparison_ran)
```

## Boolean Coercion

### Description

Elixir has a concept of a "truthy" value, where anything other than `false` or `nil` is considered `true`.

This can lead to subtle and unexpected bugs, especially when interworking with Erlang libraries. Imagine a library that performs cryptographic signature validation, with a return type of `{:ok | {:error, atom()}`. If this function were mistakenly called in a context where a "truthy" value is expected, the return value would always be considered true.

### Prevention

By using expressions that do not use boolean coercion, the incorrect assumption about the function's return type is caught early:

* Prefer `case` over `if`, `unless` or `cond`
* Prefer `and` over `&&`
* Prefer `or` over `||`
* Prefer `not` over `!`

The latter will raise a "BadBooleanError" when the function returns :ok or {:error, _}. In the interest of clarity if may even be better to use a case construct, matching explicitly on true and false.

### <span style="color:red;">Quiz</span>

**The function `SecurityCheck` below does not return a truthy value but is treated as such in both of the commented out function calls, which if statement is the correct way to call this function?**

*Uncomment the if statement that uses the correct boolean comparison.*

```elixir
defmodule SecurityCheck do
  def validate(input, password_hash) do
    case Plug.Crypto.secure_compare(input, password_hash) do
      true -> :ok
      false -> :access_denied
    end
  end

  defexception message: "There was an issue"
end

password = "some_secure_password_hash"
user_input = "some_string_which_obviously_isnt_the_same_as_the_password"
:ok
# DO NOT EDIT ANY CODE ABOVE THIS LINE =====================

# if SecurityCheck.validate(user_input, password) or raise(SecurityCheck) do :you_let_a_baddie_in end
# if SecurityCheck.validate(user_input, password) || raise(SecurityCheck) do :you_let_a_baddie_in end
```

[**<- Previous Module: GraphQL Security**](./4-graphql.livemd) || [**Next Module: Cookie Security ->**](./6-cookies.livemd)
