# ESCT: Part 5 - Elixir Security

```elixir
Mix.install([:benchwarmer, :kino, :plug])
```

## Introduction

asdf

## Table of Contents

* [Atom Exhaustion](#atom-exhaustion)
* [Protecting Sensitive Data](#protecting-sensitive-data)
* [Untrusted Code](#untrusted-code)
* [Timing Attacks](#timing-attacks)
* [Boolean Coercion](#boolean-coercion)
* [(De-)Serialization](#\(de-\)serialization)
* [Spawning External Executables](#spawning-external-executables)

## Atom Exhaustion

asdf

```elixir
random_number = :rand.uniform(10000)
malicious_user_input = Integer.to_string(random_number)

prev_count = :erlang.system_info(:atom_count)

try do
  # ONLY CHANGE THIS FUNCTION, DO NOT CHANGE THE ARGUMENT
  String.to_atom(malicious_user_input)
rescue
  e -> {ArgumentError, e}
end

IO.puts(:erlang.system_info(:atom_count) == prev_count)
```

## Protecting Sensitive Data

asdf

```elixir

```

## Untrusted Code

asdf

```elixir
name = Kino.Input.text("What's your name?")
```

```elixir
textfield_value = Kino.Input.read(name)
{result, binding} = Code.eval_string("a", a: textfield_value)
"Hello, " <> result
```

**BONUS QUESTION**: How would you go about securing the code above?

Hint: Deleting it *entirely* is a fair approach ðŸ˜‰

## Timing Attacks

asdf

```elixir
defmodule Susceptible do
  def compare(input, value) do
    case input do
      ^value -> :ok
      _ -> :access_denied
    end
  end
end

defmodule Constant do
  def compare(input, value) do
    case Plug.Crypto.secure_compare(input, value) do
      true -> :ok
      false -> :access_denied
    end
  end
end

password = "HASH_OF_THE_USERS_ACTUAL_PASSWORD"
# DO NOT EDIT ANY CODE ABOVE THIS LINE =====================

user_input = "HASH_OF_asdfasdf"

# DO NOT EDIT ANY CODE BELOW THIS LINE (you may uncomment IO.puts) =============
Benchwarmer.benchmark(fn -> Susceptible.compare(user_input, password) end)
Benchwarmer.benchmark(fn -> Constant.compare(user_input, password) end)

# IO.puts(:comparison_ran)
```

## Boolean Coercion

asdf

```elixir
defmodule SecurityCheck do
  def validate(input, password_hash) do
    case Plug.Crypto.secure_compare(input, password_hash) do
      true -> :ok
      false -> :access_denied
    end
  end

  defexception message: "There was an issue"
end

password = "some_secure_password_hash"
user_input = "some_string_which_obviously_isnt_the_same_as_the_password"
:ok

# if SecurityCheck.validate(user_input, password) or raise(SecurityCheck) do :you_let_a_baddie_in end
# if SecurityCheck.validate(user_input, password) || raise(SecurityCheck) do :you_let_a_baddie_in end
```

## (De-)Serialization

asdf

```elixir

```

## Spawning External Executables

asdf

```elixir

```

[**Next Module: Cookie Security ->**](./6-cookies.livemd)
