# ESCT: Part 5 - Elixir Security

```elixir
Mix.install([:benchwarmer, :kino, :plug])
```

## Introduction

asdf

## Table of Contents

* [Atom Exhaustion](#atom-exhaustion)
* [Protecting Sensitive Data](#protecting-sensitive-data)
* [Untrusted Code](#untrusted-code)
* [Timing Attacks](#timing-attacks)
* [Boolean Coercion](#boolean-coercion)

## Atom Exhaustion

### Description

TODO: Describe

### Prevention

TODO: Prevent

### <span style="color:red;">Quiz</span>

**Fix the vulnerable function below by changing the String function used on line 7.**

*You should get a `true` result when you successfully fix the function.*

```elixir
random_number = :rand.uniform(10000)
malicious_user_input = Integer.to_string(random_number)
prev_count = :erlang.system_info(:atom_count)

try do
  malicious_user_input
  # ONLY CHANGE THIS LINE
  |> String.to_atom()
rescue
  e -> {ArgumentError, e}
end

IO.puts("Are you protected against Atom Exhaustion?")
IO.puts(:erlang.system_info(:atom_count) == prev_count)
```

## Protecting Sensitive Data

### Description

TODO: Describe

### Prevention

TODO: Prevent

```elixir

```

## Untrusted Code

### Description

TODO: Describe

### Prevention

TODO: Prevent

### <span style="color:blue;">Example</span>

TODO: Explain

```elixir
name = Kino.Input.text("What's your name?")
```

```elixir
textfield_value = Kino.Input.read(name)
{result, binding} = Code.eval_string("a", a: textfield_value)
"Hello, " <> result
```

**BONUS QUESTION**: How would you go about securing the code above?

Hint: Deleting it *entirely* is a fair approach ðŸ˜‰

## Timing Attacks

### Description

A timing attack is a side-channel attack in which the attacker attempts to compromise a cryptosystem by analyzing the time taken to execute cryptographic algorithms.

Plainly speaking, response time it takes to compute a given function measured at the pico-second level is analyized for microscopic variations.

This technique is primarily used to analyze string comparisons of secret values to brute-force the identify of the secret.

e.g. When comparing two strings, the function exits when variation is detected. Take a secret value `MY_SECRET` and a user input `MY_PASSWORD`, the string compariosn (`MY_PASSWORD == MY_SECRET`) would go character by character until there's a complete match or a discrepency. So if the new input was `MY_SAUCE`, that new string would take marginally longer to compare against the secret than `MY_PASSWORD` because of one more similar character as `MY_SECRET`.

### Prevention

It's simple enough to protect against these types of attacks, especially during string comparisons. You need to execute functions in a way the performs them in constant time. In Elixir (and many other languages), you can use a secure string compare function that will take the same time to compare strings since it won't immediately fail at the point of first difference and instead check the full length of the string every time.

Note: constant time operations tend to take longer, that is the trade off for security. But the difference is measured in clock cycles at that point.

### <span style="color:red;">Quiz</span>

**Observe the two functions outlined below, one is susceptible to timing attacks and the other uses constant time to compare strings. Change the value of `user_input` and see if you notice any time difference in the execution time.**

*Simply uncomment the IO.puts on the last line of the code block for credit on this question.*

```elixir
defmodule Susceptible do
  def compare(input, value) do
    case input do
      ^value -> :ok
      _ -> :access_denied
    end
  end
end

defmodule Constant do
  def compare(input, value) do
    case Plug.Crypto.secure_compare(input, value) do
      true -> :ok
      false -> :access_denied
    end
  end
end

password = "HASH_OF_THE_USERS_ACTUAL_PASSWORD"
# DO NOT EDIT ANY CODE ABOVE THIS LINE =====================

user_input = "HASH_OF_asdfasdf"

# DO NOT EDIT ANY CODE BELOW THIS LINE (you may uncomment IO.puts) =============
Benchwarmer.benchmark(fn -> Susceptible.compare(user_input, password) end)
Benchwarmer.benchmark(fn -> Constant.compare(user_input, password) end)

# IO.puts(:comparison_ran)
```

## Boolean Coercion

### Description

Elixir has a concept of a "truthy" value, where anything other than `false` or `nil` is considered `true`.

This can lead to subtle and unexpected bugs, especially when interworking with Erlang libraries. Imagine a library that performs cryptographic signature validation, with a return type of `{:ok | {:error, atom()}`. If this function were mistakenly called in a context where a "truthy" value is expected, the return value would always be considered true.

### Prevention

By using expressions that do not use boolean coercion, the incorrect assumption about the function's return type is caught early:

* Prefer `case` over `if`, `unless` or `cond`
* Prefer `and` over `&&`
* Prefer `or` over `||`
* Prefer `not` over `!`

The latter will raise a "BadBooleanError" when the function returns :ok or {:error, _}. In the interest of clarity if may even be better to use a case construct, matching explicitly on true and false.

### <span style="color:red;">Quiz</span>

**The function `SecurityCheck` below does not return a truthy value but is treated as such in both of the commented out function calls, which if statement is the correct way to call this function?**

*Uncomment the if statement that uses the correct boolean comparison.*

```elixir
defmodule SecurityCheck do
  def validate(input, password_hash) do
    case Plug.Crypto.secure_compare(input, password_hash) do
      true -> :ok
      false -> :access_denied
    end
  end

  defexception message: "There was an issue"
end

password = "some_secure_password_hash"
user_input = "some_string_which_obviously_isnt_the_same_as_the_password"
:ok
# DO NOT EDIT ANY CODE ABOVE THIS LINE =====================

# if SecurityCheck.validate(user_input, password) or raise(SecurityCheck) do :you_let_a_baddie_in end
# if SecurityCheck.validate(user_input, password) || raise(SecurityCheck) do :you_let_a_baddie_in end
```

[**<- Previous Module: GraphQL Security**](./4-graphql.livemd) || [**Next Module: Cookie Security ->**](./6-cookies.livemd)
