# ESCT: Part 3 - Secure SDLC Concepts

## Introduction

Welcome to Part 3! This section is dedicated to discussing some of the more abstract, non-vulnerability related parts of Application Security. Concepts to keep in mind as you work your craft at building code.

## Table of Contents

* [No Secrets In Code](#no-secrets-in-code)
* [Making Secret Rotation Easy](#making-secret-rotation-easy)
* [Rate Limiting](#rate-limiting)
* [Principle of Least Privilege](#principle-of-least-privlege)

## No Secrets In Code

### Description

While it may seem obvious, having secrets such as passwords or auth_tokens hard coded in your files is a big yikes! Even if you catch it later, more than likely your code has been uploaded to a Version Control System and is now in your commit history - which can be [scary / difficult to undo](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository).

More than that, while it may be convenient for testing / building typically in production you don't care about those secrets anyways - so you might as well incorporate them securely from the get go!

### Prevention

There are a number of different ways you can manage your secrets for use in production systems. Most of them are implementation specific which varies on your build and deploy processes.

A very easy way to prevent secrets being added to go though is to access them via Environment Variables!

### <span style="color:red">QUIZ</span>

**Remove the hard-coded secret from the code sample below and replace it with an environment variable named `envar_secret`.**

*Use `System.get_env/1` on line 2.*

```elixir
# let's assume there is an environment variable named 'envar_secret'
super_secret_password = "p@ssw0rd"

# DO NOT CHANGE CODE BELOW THIS COMMENT
IO.puts(super_secret_password)
```

## Making Secret Rotation Easy

### Description

So the unthinkable happened and a secret value you didn't want getting out there, got out there. It happens to the best of them...[a lot](https://www.google.com/search?q=secret+token+exposed+tech+company&source=lnms&tbm=nws).

Let's just hope that we made it easy to rotate tokens out! What's that you say? If we change a Service to Service token in one place, we would have to change it simultaneously in every service that uses it? Well...how many services do we have...? **1000**?!

### Prevention

The half-serious situation described above outlines a common problem that can be solved by integrating your applications to use a Key Management Service (KMS) to handle secrets. A simple enough solution that is harder to implement later on, so you're best to integrate it from the onset.

Additionally, thought can be put into how you architect data flows with regards to how secrets will be used (as to avoid a secret being used in multiple places).

## Rate Limiting

### Description

While performing their designed operations, applications send traffic across networks, make client requests, generate server responses, and consume processing and memory capacity from the computing machines on which they are hosted. They often have components, like APIs that interact with data sources and services. Simply put - modern applications have a lot of things happening!

When building an application, it is necessary to consider approaches to manage the access and use of all relevant internal / external resources involved in the context of the application. This will help ensure the continued availability of the application and it's functionality for all legitimate users and entities. This is particularly important for applications that run critical infrastructure and other key services organizations rely on for business operations.

When resources are not well managed, applications become vulnerable to negative impacts in performance, unintentional service failures, and denial of service attacks, in which a malicious actor takes advantage of resource limitations to intentionally overwhelm and crash a system.  

Implementing rate limiting is one security best practice that can help mitigate the ability of unlimited, undefined, or uncontrolled application input, to intentionally or inadvertently exahaust vital resources across all levels of application's context.

### Implementation Approaches
There are multiple approaches to implementing rate limiting within an application and in general the approach is based on at least one of the following problematic scenarios:

* Malicious actor-generated abusive traffic designed to force the application into a compromised state 
* Malicious or legitimate users perform large load activities that requires significant processing power 
* Malicious or legitimate users sending large number of queries, often repeatedly to the service
* Malicious or legitimate users sending large number of queries in a narrow timeframe

Rate limiting can be implemented to protect against a variety of attacks or abuses:

* Preventing Denial Of Service attacks (limiting the number of calls to expensive endpoints)
* Limiting brute force attempts (such as on one time codes and passwords)
* Programmatic abuse of services

### Prevention

Per OWASP, consider limits on the following (please see Rate Limiting References below):

* Execution timeouts
* Max allocable memory
* Number of file descriptors
* Number of processes
* Request payload size (e.g., uploads)
* Number of requests per client/resource
* Number of records per page to return in a single request response

When rate limiting a new action, begin by asking these questions:

* "What are the maximum number of calls to my action that a reasonable non-malicious user would feasibly make in a given time period?"
* "Is calling this action an expensive operation? If yes, how many calls in a minute would be enough to overburden the service?"
* "Is this action a candidate for brute force attacks?" (E.g. passwords, authentication tokens, one time passcodes)

If the answer to one or more of those questions is yes, consider putting a limit on the number of times that the action can be called. Good rate limiting keeps in mind legitimate use cases and does not block regular user functionality, but protects the service from malicious or burdensome behavior.

More often than not, rate limiting should be as specific as possible. For instance, it is better to add rate limiting on a single GraphQL type than to add a generic limit to the entire /GraphQL endpoint.

Two approaches to rate limiting
-Application Level...
-Network level...

### Application Level Rate Limiting - 

Rate limiting around Application Features and Functionality - For instance a single user who has access to your application and therefore certain features within the application that respond to user requests for specific actions for instance like uploading a file, sending messages, etc. While developing an application, it is important to implement limits around how much and what actions users can take and how often. 

### <span style="color:blue;">Example</span>

The Elixir language has a built-in rate-limiter called Hammer (https://hexdocs.pm/hammer/frontpage.html).  Some organizations chose to apply limits based on userId as in the example below. 

The check_rate function below takes 3 arguments:

1. The first is what we've decided apply the limit to, in this case, the userID
2. The second, 60_000, represents the number of milliseconds in 1 minute (1000 milliseconds per 1 second, 60 seconds in 1 minute)
3. The last, 10, represents the number of times the userID can appear to have done a particular action before we stop them.  In this case, 10 times. 

```
# limit file uploads to x per minute per user
userId = getUserId()
case Hammer.check_rate("action:#{userId}", 60_000, 10) do
  {:allow, _count} ->
    # let them do it
  {:deny, _limit} ->
    # nope
end
```

### Network Level Rate Limiting - Network traffic -> Firewalls 
Source IP address, destination for server hosting your service
Firewall, are traditionally a network device that filters traffic based on configured access control list that defines good traffic and depending on the firewall captures/analyzes network packets and blocks bad traffic.  

Firewall functionality implemented at the application level, Web Application Firewalls (WAF) operate similarly by specificly looking at Web traffic, over HTTP/HTTPS port 80 443 for malicious incoming from sources across the internet.  

### <span style="color:blue;">Example</span>

If your public facing URI/URL for your application is hxxps://yourapplication.org/login

```
The following is an example of requests that can come from across the internet targeting your application from the same source IP 123.123.123.123 for instance:
hxxps://yourelixirapplication.org/secret
hxxps://yourelixirapplication.org/admin
hxxps://yourelixirapplication.org/login?user=test
hxxps://yourelixirapplication.org/login?user=test&pass=test
.....

```
Your site will handle these incoming requests either by returning 404 responses, etc.  Imagine receiving thousands of these requests, however, as can be generated by automated tools freely available to malicious users.  If your server/service processing these request was not built/designed to anticipate this scenario, the server could crash. 

A WAF can be configured to limit the number of tries from the same IP address.  In the above example, if the same IP is the source for more than 100 of these attempts within 5 seconds, the WAF can ensure those requests don't reach your application.  


### Rate Limiting References
1. https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html#rate-limiting
2. https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa4-lack-of-resources-and-rate-limiting.md

## Principle of Least Privilege

Sometimes known as the Principle of Minimal Privilege or the Principle of Least Authority, the Principle of Least Privilege (PoLP) means that every entity* is only strictly given the essential privileges needed to perform its requirement.

E.g. A script that executes on a cron schedule that monitors the output of a log file only needs read privileges and should not be given write privileges.

**Entity: generic term for an arbitrary process, user, program, etc. found within a Data System*

### Benefits of the Principle

* **Better Data System Stability** - When an entity is limited in the scope of changes it can make to a system, it is easier to test its possible actions and interactions in the context of the Data System.
* **Better Data System Security** - When an entity is limited in the system-wide actions it may perform, vulnerabilities / compromises in one application cannot be used to exploit the rest of the business or adjacent Data Systems.
* **Ease of Deployment** - In general, the fewer privileges an entity requires, the easier it is to deploy within a larger environment.
  <br /><br />
  [**<- Previous Module: OWASP**](./2-owasp.livemd) || [**Next Module: GraphQL Security ->**](./4-graphql.livemd)
